#!/usr/bin/env ruby
# Save your fork, there's cake!"
require 'find'
require 'open-uri'
require 'socket'
require 'fileutils'
require 'io/wait'
require 'pp'

CLOJURE = "1.2.0"
STABLE  = "0.6.3"

def parse_opts(args)
  args.unshift('run')     if args.any? and args.first.index('/')
  args.unshift('default') if args.empty? or ['-', '@'].include?(args.first[0,1])

  task = args.first.to_sym
  opts = Hash.new {|h,k| h[k] = []}
  args.each do |opt|
    case opt
    when "--"                 then break # stop parsing options
    when /^@([-\w]+)$/        then opts[:context] << $1
    when /^-(\w+)$/           then $1.split('').each {|c| opts[c.to_sym] << ''}
    when /^--?([-\w]+)=(.+)$/ then opts[$1.to_sym].concat($2.split(','))
    when /^--?([-\w]+)$/      then opts[$1.to_sym] << ""
    else                           opts[task] << opt
    end
  end
  task, opts.freeze
end

def parse_config(*paths)
  config = {}
  paths.each do |path|
    File.open(path, 'r') do |file|
      file.each do |line|
        next if ['#', '!'].include?(line[0,1])
        key, value = line.split('=', 2)
        next unless key and value
        config[key.strip] = value.strip
      end
    end if File.exists?(path)
  end
  config.freeze
end

def log(command, *messages)
  messages.each do |message|
    message.split("\n").each do |line|
      printf("%11s %s\n", "[#{command}]", line) unless line.empty?
    end
  end
end

def project_dir(dir)
  if $opts[:project] and not $opts[:global]
    project = $opts[:project].last
    raise "project dir #{project} does not exist" unless File.exists?(project)
    return project
  end

  while dir != File.dirname(dir)
    return dir if ["project.clj", "tasks.clj"].any? {|file| File.exists?("#{dir}/#{file}")}
    dir = File.dirname(dir)
  end unless $opts[:global]
  "#{$home}/.cake"
end

def readlink(file)
  link = File.readlink(file)
  return file if link == file
  link = "#{File.dirname(file)}/#{link}" unless link.index('/') == 0
  readlink(link)
rescue NotImplementedError, Errno::EINVAL
  file
end

GET = system('which wget > /dev/null') ? "wget -O" : "curl -fo" # prefer wget because it retries on incomplete transfers
def download(url, path)
  return path if File.exists?(path)
  FileUtils.makedirs(File.dirname(path))
  puts "Downloading #{url}..."
  system("#{GET} #{path} #{url}") || begin
    FileUtils.rm_f(path)
    raise "unable to fetch #{url} with curl or wget"
  end
  path
end

def get(repo, source_jar, dest_jar = source_jar)
  download("#{repo}/#{source_jar}", "#{$m2}/#{dest_jar}")
end

def ps
  `jps -v`.split("\n").select {|l| l =~ /cake\.project/}
rescue Errno::ENOENT => e
  puts "jps was not found on your PATH. Please add it."
  raise e
end

def cake_pids
  ps.collect {|line| line.split(' ').first.to_i}
end

def killall
  cake_pids.each do |pid|
    Process.kill($opts[:"9"] ? KILL : TERM, pid)
  end.size > 0
end

def tail_log(num_lines)
  exec("tail -n#{num_lines || 10} -f #{$project}/.cake/cake.log")
end

class Cake
  def repl
    puts ";; cannot find readline; your repl won't be very awesome without it" if $no_readline
    load_history
    loop do
      with_socket do |socket|
        socket.write %{[repl, "#{PROMPT}"] #{$vars}}
        while @ns = read_until_prompt(socket)
          line = readline
          return unless line
          socket.write(line + "\n")
        end
      end
    end
  ensure
    save_history
  end

  def send_command(command)
    with_socket do |socket|
      cmd = [command, PROMPT].to_clj
      log(command, "sending: " + cmd) if debug?
      socket.write("#{cmd} #{$vars}")
      socket.duplex($stdin, $stdout) do |line|
        if line =~ /^#{PROMPT}(.*)$/
          socket.write(prompt($1))
        elsif line =~ /^@#{PROMPT}(.*)$/
          socket.write(prompt($1, :echo => false))
        else
          line
        end
      end
    end
  end

private

  HISTORY_NUM  = 500
  HISTORY_FILE = ".cake/history"
  def load_history
    open(HISTORY_FILE) do |file|
      file.each {|line| Readline::HISTORY << line.chomp}
    end if File.exists?(HISTORY_FILE)
  end

  def save_history
    open(HISTORY_FILE, 'w') do |file|
      history = Readline::HISTORY.to_a
      file.puts(history[-HISTORY_NUM..-1] || history)
    end
  end

  def read_until_prompt(socket)
    prompt = nil
    socket.duplex($stdin, $stdout, 3) do |line|
      if line =~ /^(.*)#{PROMPT}(.*)$/
        prompt = $1.empty? ? $2 : "#{$1}\n#{$2}"
        nil
      else
        line
      end
    end
    prompt
  end

  def complete?(input)
    return true if input.empty?
    with_socket do |socket|
      socket.write(":validate {} #{input.join("\n").strip}")
      socket.close_write # send eof
      socket.gets != "incomplete\n"
    end
  end

  Readline.basic_word_break_characters = " \t\n\"'`~@;#&{}()[]"
  def readline
    input = []
    prompt = "#{@ns}=> "
    Readline.completion_proc = method(:completions)
    while line = Readline.readline(prompt)
      input << line
      if complete?(input)
        Readline::HISTORY.push(input.join(' '))
        return input.join("\n")
      end
      if $config['repl.disable-secondary-prompt'] == 'true'
        prompt = ' ' * prompt.length
      else
        prompt[-2] = ?*
      end
    end
  rescue Interrupt => e
    return nil if input.empty?
    Readline::HISTORY.push(input)
    retry
  end

  def completions(prefix)
    return [] if prefix.empty?
    with_socket do |socket|
      socket.write ~[:completions, {}, ~[prefix, ~@ns, $opts[:cake]]]
      completions = []
      while line = socket.gets
        completions << line.chomp
      end
      completions
    end
  end

  def prompt(prompt, opts = {})
    if opts[:echo] == false
      output = `stty -echo 2>&1`
      log($command, output) if verbose?
      echo_off = $? == 0
      prompt << ' (WARNING, input will be visible on console!)' unless echo_off
      prompt << ':'
    end
    input = Readline.readline(prompt + ' ') || ''
    input + "\n"
  ensure
    if echo_off
      system('stty echo')
      puts
    end
  end
end

def initialize_cake_dirs
  FileUtils.makedirs("#{$project}/.cake/run")
  FileUtils.makedirs("#{$home}/.cake/run")
  project_clj = "#{$home}/.cake/project.clj"
  File.open(project_clj, 'w') do |file|
    file.write <<END
(defproject global "0.0.0"
  :description "Don't rename this project, but you can change the version if you want."
  :dependencies [[clojure "#{CLOJURE}"]
                 [clojure-contrib "#{CLOJURE}"]]
  :copy-deps true)
;;--------------------
;; This is the global cake project. What does that mean?
;;  1. This project is used whenever you run cake outside a project directory.
;;  2. Any dependencies specified here will be available in the global repl.
;;  3. Any dev-dependencies specified here will be available in all projects, but
;;     you must run 'cake deps --global' manually when you change this file.
;;  4. Configuration options in ~/.cake/config are used in all projects.
;;--------------------
END
  end unless File.exists?(project_clj)

  # Enable paren matching if using readline and .inputrc doesn't exist.
  inputrc = "#{$home}/.inputrc"
  File.open(inputrc, 'w') do |file|
    file.write "set blink-matching-paren on\n"
  end unless $no_readline or $libedit or File.exists?(inputrc)
end

#==================================

$task, $opts = parse_opts(ARGV)
$script      = File.expand_path($opts[:run].first) if $opts[:run]
$pwd         = Dir.getwd
$project     = project_dir($pwd)
$file        = File.expand_path(__FILE__)
$cakedir     = File.dirname(File.dirname(File.expand_path(readlink($file), File.dirname($file))))
$releases    = "http://releases.clojure-cake.org"
$m2          = "#{HOME}/.m2/repository"
$config      = Config.new("#{HOME}/.cake/config", "cake.config", ".cake/config")
$vars        = {:env => ENV.to_hash, :pwd => $pwd, :args => ARGV, :opts => $opts, :script => $0}.to_clj
$timeout     = ($config['connect.timeout'] || 60).to_i

initialize_cake_dirs
Dir.chdir($project)

# Bootstrap cake dependencies.
if File.exists?("#{$cakedir}/src/cake/core.clj") and File.exists?("#{$cakedir}/project.clj") and not stable?
  log(:cake, "running from git checkout") if verbose?
  if $command == :upgrade
    log(:upgrade, "pulling latest code from git")
    Dir.chdir($cakedir) do
      system('git pull')
      system('cake deps -S')
    end
  end

  $version = `cd #{$cakedir} && git describe`.chomp
  cakepath = ["#{$cakedir}/src", "#{$cakedir}/lib/*"]
  bakepath = "#{$cakedir}/dev"
else
  log(:cake, "running from ~/.m2") if verbose?
  download("#{$releases}/cake", __FILE__) if $command == :upgrade

  $version = STABLE
  clojure  = get("http://build.clojure.org/releases", "org/clojure/clojure/#{CLOJURE}/clojure-#{CLOJURE}.jar")
  cakejar  = get($releases, "jars/cake-#{$version}.jar", "cake/cake/#{$version}/cake-#{$version}.jar")
  bakejar  = get($releases, "jars/bake-#{$version}.jar", "bake/bake/#{$version}/bake-#{$version}.jar")

  cakepath = [cakejar, clojure, bakejar]
  bakepath = bakejar
end
log(:deps, "cake version is #{$version}") if debug?

cake = JVM.new(
  [bakepath, cakepath, "src", "src/clj", "#{$home}/.cake/lib/dev/*"],
  [$config['jvm.library.path'], "lib/ext/native", "lib/native", "lib/dev/native"],
  ["-Dcake.project=#{$project}", "-Dbake.path=#{bakepath}"]
)

if $command == :upgrade
  killall
  puts "cake upgraded to #{$version}"
  exit
elsif $command == :default and $opts[:version]
  puts "cake #{$version}"
  exit
elsif $command == :log
  tail_log($opts[:log])
elsif $command == :killall
  killall || puts("No matching processes belonging to you were found")
  exit
elsif $command == :kill
  cake.kill
  exit
elsif $command == :ps
  puts ps.sort.reverse
  exit
end

cake.kill if restart?
cake.start

if $command == :console
  num_windows = $opts[:console].first || 1
  interval    = $opts[:i] ? $opts[:i].first : 4
  system("jconsole -interval=#{interval}" + " #{cake.pid}" * num_windows.to_i + "&")
elsif $command == :repl
  cake.repl
else
  cake.send_command($command)
end

tail_log(0) if $opts[:l]
